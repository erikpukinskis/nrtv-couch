var requirejs = require("requirejs")
var define = requirejs.define

// Here's the simplest possible example, with a single custom tie:

define(
  "super-simple-example",
  ["component", "chai", "supertest", "nrtv-server"],
  function(component, chai, request, Server) {
    var expect = chai.expect

    // We need a super simple tie type that just starts up a server that prints out some text:

    function TextTie(text) {
      this.instance = new Server
      this.instance.get(
        "/", 
        function(request, response) {
          response.send(text)
        }
      )
    }
    TextTie.prototype.start =
      function(callback) {
        this.instance.start(5511)
      }

    TextTie.prototype.stop =
      function() {
        this.instance.stop()
      }


    // That's basically as simple as it gets. Usually there's at least two ties. But this is the simplest test.

    // So let's add that the text server tie type:

    component.addTypeOfTie(
      "text", 
      TextTie,
      ["stop", "start"]
    )


    // And then we can call that boot function:

    var Hello = component()
    Hello.text("Hello worldkins!")
    var instance = new Hello()
    instance.start()

    // Now we should see some magic!

    request(
      "http://localhost:5511"
    )
    .get("/")
    .end(function(x, response) {
      console.log(response.text)
      expect(response.text).to.match(
        /worldkins/
      )
      instance.stop()
    })
  }
)

// And here's an example that uses the real ties. 

define(
  "important-person-texting-component",
  ["sms", "nrtv-element", "component", "nrtv-bridge-tie", "nrtv-server-tie", "nrtv-element-tie"],
  function(sms, element, component, bridgeTie, serverTie, elementTie) {
    var Texter = component(bridgeTie, serverTie, elementTie)

    var server = Texter.server()

    var bridge = Texter.bridge(server)

    var successMessage = Texter.element(".success.hidden", "Success! You da real MVP.")

    var showSuccess = successMessage.showOnClient(bridge)

    var textSomeone = server.route(
      "post", 
      "/text",
      function(x, response) {
        sms.send(
          "812-320-1877",
          "Erik, do something!"
        )

        response.json(showSuccess)
      }
    )

    var body = Texter.element([
      element(
        "Press the button!"
      ),
      successMessage,
      element(
        "button.do-it",
        {
          onclick: textSomeone
            .makeRequest(bridge) 
            // could give data here!
        }, 
        "Do iiiiit"
      )
    ])

    server.route(
      "get",
      "/",
      bridge.sendPage(body)
    )

    return Texter
  }
)

// We'll need an sms module to exist, but we're not going to actually use it, so let's just make an empty one.

define("sms", function() {
  return {
    send: function() {
      throw new Error("We don't actually want to be here!")
    }
  }
})

// Let's test to see if that works:

define(
  "important-person-test",
  [
   "important-person-texting-component"
   , "chai", "sms", "sinon", "zombie", "sinon-chai", "html"
  ],
  function(Texter, chai, sms, sinon, Browser, sinonChai, html) {

    var expect = chai.expect
    chai.use(sinonChai);

    sinon.stub(sms, 'send')

    var instance = new Texter()
    instance.start(3090)

    Browser.localhost("localhost", 3090);

    var browser = new Browser()
    browser.on("error", function(e) {
      throw(e)
    })


    browser.visit("/", function() {

      browser.assert.hasClass('.success', 'hidden')

      browser.pressButton(
        ".do-it",
        runChecks
      )
    })

    function runChecks() {
      instance.stop()

      console.log("\n==============\n")
      console.log(html.prettyPrint(browser.html()))

      browser.assert.hasNoClass('.success', 'hidden')

      console.log("message is visible!")

      // And then we just expect that someone tried to sms me. This is a handy side-effect of having stubbed sms.send before. Now we can check to see if it was called. You can't do that unless you stub it.

      expect(sms.send).to.have
      .been.calledWith(
        "812-320-1877",
        "Erik, do something!" 
      )

      console.log("sms got called!")
    }      

  }
)

requirejs(["component", "chai"], function(component, chai) {
  var expect = chai.expect
  var log = []

  function Pants() {}
  function Shirt(color) {
    this.color = color
  }

  Pants.prototype.wake =
    function(time, callback) {
      setTimeout(function() {
        log.push("put on pants at "+time)
        callback()
      }, 0)
    }

  Shirt.prototype.wake =
    function(time, callback) {
      log.push("donned "+this.color+" shirt around "+time)
      callback()
    }

  component.addTypeOfTie("pants", Pants, ["wake"])

  component.addTypeOfTie("shirt", Shirt, ["wake"])

  var Me = component(Pants, Shirt)
  Me.pants()
  Me.shirt("red")
  var me = new Me

  var timeout = setTimeout(function() {
    throw new Error("Never got called back from waking up!")
  }, 1000)

  me.wake("6:55am", function() {
    clearTimeout(timeout)

    expect(log).to.have.include(
      "put on pants at 6:55am"
    )
    expect(log).to.have.include(
      "donned red shirt around 6:55am"
    )
    console.log("Pants and shirt called back!")
  })

})

require("requirejs")(
  ['super-simple-example'],
  function(example) {
    requirejs(
      ['important-person-test'],
      function(test) {}
    )
  }
)
