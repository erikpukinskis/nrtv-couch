if (typeof define !== 'function') {
  var define = require('amdefine')(
    module)}

// Component

// Most people when they want to make something happen with software, need to pull together a couple different kinds of things. Maybe you want a button on your thing that when people hit it they can sign up for some text messages that are going to get sent to them according to some pattern. That's a couple different kinds of things: a widget people can interact with, some sort of off-line activity that springs to life and sends messages at particular times. A thing that remembers the phone numbers, etc.

// There's potentially some complexity behind each of those things, so beyond the simplest cases you want to have separate modules that take care of the specifics. But you need something that describes how those different modules fit together.[1]


// So let's make it work.

define(
  function() {

  var sharedStatics = {}

  function component() {
    var componentConstructor = 
      function() { /* */ }

    // We should probably just bind addTypeOfTie to the constructor and pass that to the tie (or something)

    for (i in arguments) {
      if (typeof arguments[i] != "function") {
        throw new Error("Tried to pass "+arguments[i]+" to component, but it's not a component tie")
      }
      arguments[i](component)
    }

    for (key in sharedStatics) {
      componentConstructor[key] = 
        sharedStatics[key]
    }

    return componentConstructor
  }

  // Component ties are different than modules. Modules don't know about the other modules that use them... the "button" module and the "sms" module know nothing about each other. As far as each is concerned, the other is speaking gibberish. Modules only know about the specific handful of modules they need to do their jobs.

  // But component ties know about each other. The template tie knows about the route tie. More distant ties might not be able to coordinate... the database tie doesn't know anything about buttons. But other ties do.

  // Which means ties all sort of form little neighborhoods. Around the button tie is a neighborhood of ties that know how to do stuff with buttons.

  // So. We'll need a way to tell our component about the types of ties available to it.

  component.addTypeOfTie =
  function(name, tieConstructor, exports) {

    // Each type of tie gets a function on the component:

    sharedStatics[name] =
    function() {

      // We grab the arguments for constructing the tie

      var args = [null].concat(
        Array.prototype.slice.call(
          arguments, 0
        )
      )

      // We bind the constructor to those arguments

      var boundConstructor = 
        tieConstructor.bind.apply(
          tieConstructor, 
          args
        )

      // And then instantiate the tie

      var tie = new boundConstructor()
      var events = this.prototype.__events = this.prototype.__events || {}

      // Some ties want to make some of their methods publically available on the component:

      for (i=0; i<(exports && exports.length); i++) {

        var key = exports[i]

        if (!events[key]) {
          events[key] = []
          this.prototype[key] =
            hitTies(key)
        }

        // FIXME this should happen in the tie constructor, not in addTypeOfTie

        events[key].push(
          tie[key].bind(tie)
        )
      }

      return tie
    }
  }

  function hitTies(key) {
    return function() {
      var args = Array.prototype.slice.call(arguments)

      var lastArgIsFunction = typeof args[args.length-1] == "function"

      if (lastArgIsFunction) {
        var callback = args.pop()
      }

      var ev = this.__events[key]
      var outForDelivery = ev.length
      args.push(function() {
        outForDelivery--
        if (outForDelivery == 0) {
          callback()
        }
      })

      for(var i=0; i<ev.length; i++) {
        ev[i].apply(this, args)
      }
    }
  }

  return component
})



// [1] Often people let a "framework" handle that logic, and their modules work together purely by dint of being in the same folder together. Or they have several "glue" files that make a whole bunch of one specific type of connection. Like gluing all the routes to their controllers. But then there's a whole other place that glues the controllers to their database representations. And whole other place that glues the routes to actions in the user interface. Without a single thing whose job is to glue together a concern, when you want to understand what, say, hitting a button *does*, you have to hold in your head the entire logic of the framework. Building components is making those relationships all specific and creating a place where they can all live together.